<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenClaw Architecture - Concrete View</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0e14;
            color: #e6e6e6;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #ff6b6b;
        }

        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            color: #888;
        }

        .scenario-selector {
            background: #1a1f2e;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
        }

        .scenario-btn {
            background: #2d3548;
            color: #e6e6e6;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-size: 0.95em;
        }

        .scenario-btn:hover {
            background: #3d4558;
        }

        .scenario-btn.active {
            background: #ff6b6b;
        }

        #graph {
            background: #1a1f2e;
            border-radius: 12px;
            border: 2px solid #2d3548;
        }

        .node {
            cursor: pointer;
            stroke: #fff;
            stroke-width: 2px;
        }

        .node.selected {
            stroke: #ff6b6b;
            stroke-width: 4px;
        }

        .link {
            stroke-width: 3px;
            stroke: #4a90e2;
            marker-end: url(#arrowhead);
        }

        .link.memory {
            stroke: #e74c3c;
        }

        .link.control {
            stroke: #f39c12;
            stroke-dasharray: 5,5;
        }

        .link.retrieval {
            stroke: #2ecc71;
            stroke-dasharray: 2,3;
        }

        .node-label {
            font-size: 13px;
            font-weight: 600;
            fill: #e6e6e6;
            pointer-events: none;
            text-anchor: middle;
        }

        .node-sublabel {
            font-size: 11px;
            fill: #888;
            pointer-events: none;
            text-anchor: middle;
        }

        .link-label {
            font-size: 11px;
            fill: #4a90e2;
            pointer-events: none;
            text-anchor: middle;
        }

        .info-panel {
            position: absolute;
            top: 100px;
            right: 30px;
            width: 300px;
            background: #1a1f2e;
            border: 2px solid #2d3548;
            border-radius: 12px;
            padding: 20px;
            display: none;
        }

        .info-panel h3 {
            color: #ff6b6b;
            margin-bottom: 10px;
        }

        .info-panel p {
            font-size: 0.9em;
            line-height: 1.6;
            margin: 8px 0;
        }

        .info-panel .label {
            color: #888;
            font-size: 0.8em;
            text-transform: uppercase;
            margin-top: 15px;
            margin-bottom: 5px;
        }

        .legend {
            background: #1a1f2e;
            border: 2px solid #2d3548;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 0.9em;
        }

        .legend-line {
            width: 40px;
            height: 3px;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>OpenClaw Architecture - Concrete Implementation</h1>
        <p class="subtitle">Real data flows, not abstract concepts</p>

        <div class="scenario-selector">
            <button class="scenario-btn active" onclick="loadScenario('message_flow')">
                Discord Message Flow
            </button>
            <button class="scenario-btn" onclick="loadScenario('memory_consolidation')">
                Memory Consolidation
            </button>
            <button class="scenario-btn" onclick="loadScenario('skill_loading')">
                Skill Loading
            </button>
            <button class="scenario-btn" onclick="loadScenario('heartbeat')">
                Heartbeat System
            </button>
            <button class="scenario-btn" onclick="loadScenario('full')">
                Full Architecture
            </button>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-line" style="background: #4a90e2;"></div>
                <span>Data Flow</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #e74c3c;"></div>
                <span>Memory Write</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #2ecc71; border-style: dashed;"></div>
                <span>Memory Read</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #f39c12; border-style: dashed;"></div>
                <span>Control Signal</span>
            </div>
        </div>

        <svg id="graph" width="1560" height="800"></svg>

        <div class="info-panel" id="info-panel">
            <h3 id="info-title"></h3>
            <div class="label">Implementation</div>
            <p id="info-implementation"></p>
            <div class="label">Key Details</div>
            <p id="info-details"></p>
        </div>
    </div>

    <script>
        const scenarios = {
            message_flow: {
                title: "Discord Message Flow",
                nodes: [
                    {id: "discord", label: "Discord Message", sublabel: "User: @Moltbot hello", x: 100, y: 100, color: "#3498db"},
                    {id: "gateway", label: "Gateway (Port 18789)", sublabel: "WebSocket server", x: 300, y: 100, color: "#9b59b6"},
                    {id: "router", label: "Session Router", sublabel: "Routes by channel+sender", x: 500, y: 100, color: "#9b59b6"},
                    {id: "attention", label: "Attention Filter", sublabel: "requireMention: true", x: 700, y: 50, color: "#f39c12"},
                    {id: "session", label: "Session Context", sublabel: "~130k tokens", x: 900, y: 100, color: "#e74c3c"},
                    {id: "llm", label: "LLM (Claude Opus 4.5)", sublabel: "Inference with system prompt", x: 1100, y: 100, color: "#9b59b6"},
                    {id: "tools", label: "Tool Selection", sublabel: "bash, read, write, browser", x: 1300, y: 150, color: "#16a085"},
                    {id: "response", label: "Discord Response", sublabel: "Streaming output", x: 1300, y: 50, color: "#3498db"}
                ],
                links: [
                    {source: "discord", target: "gateway", label: "WebSocket", type: "data"},
                    {source: "gateway", target: "router", label: "Route", type: "data"},
                    {source: "router", target: "attention", label: "Check", type: "control"},
                    {source: "attention", target: "session", label: "If mentioned", type: "data"},
                    {source: "session", target: "llm", label: "Context", type: "data"},
                    {source: "llm", target: "response", label: "Generate", type: "data"},
                    {source: "llm", target: "tools", label: "Tool calls", type: "data"}
                ],
                description: "How a Discord message becomes a response"
            },
            memory_consolidation: {
                title: "Memory Consolidation Pipeline",
                nodes: [
                    {id: "session", label: "Session Context", sublabel: "Working memory (~130k tokens)", x: 200, y: 100, color: "#e74c3c"},
                    {id: "trigger", label: "Consolidation Trigger", sublabel: "Capacity exceeded OR session end", x: 450, y: 100, color: "#f39c12"},
                    {id: "daily", label: "Daily Log", sublabel: "memory/2026-02-05.md", x: 700, y: 50, color: "#e74c3c"},
                    {id: "vector", label: "Vector Index", sublabel: "~400 token chunks", x: 700, y: 150, color: "#2ecc71"},
                    {id: "semantic", label: "MEMORY.md", sublabel: "Curated facts (manual)", x: 950, y: 100, color: "#e74c3c"},
                    {id: "search", label: "Semantic Search", sublabel: "memory_search tool", x: 1200, y: 100, color: "#2ecc71"}
                ],
                links: [
                    {source: "session", target: "trigger", label: "When full", type: "control"},
                    {source: "trigger", target: "daily", label: "Append event", type: "memory"},
                    {source: "daily", target: "vector", label: "Index", type: "memory"},
                    {source: "semantic", target: "vector", label: "Index", type: "memory"},
                    {source: "vector", target: "search", label: "Query", type: "retrieval"}
                ],
                description: "4-tier memory hierarchy in action"
            },
            skill_loading: {
                title: "Progressive Skill Disclosure",
                nodes: [
                    {id: "system", label: "System Prompt", sublabel: "Loaded every turn", x: 150, y: 100, color: "#9b59b6"},
                    {id: "index", label: "Skills Index", sublabel: "700 skills, ~5k tokens", x: 400, y: 100, color: "#2ecc71"},
                    {id: "llm", label: "LLM Decision", sublabel: "Match task to skill", x: 650, y: 100, color: "#9b59b6"},
                    {id: "read", label: "Read Tool", sublabel: "Load SKILL.md", x: 900, y: 100, color: "#16a085"},
                    {id: "skill_doc", label: "Full Skill Doc", sublabel: "~2k tokens of instructions", x: 1150, y: 100, color: "#2ecc71"},
                    {id: "execute", label: "Execute Skill", sublabel: "Run the actual skill code", x: 1400, y: 100, color: "#16a085"}
                ],
                links: [
                    {source: "system", target: "index", label: "Includes", type: "data"},
                    {source: "index", target: "llm", label: "Browse", type: "data"},
                    {source: "llm", target: "read", label: "read(SKILL.md)", type: "data"},
                    {source: "read", target: "skill_doc", label: "Load", type: "retrieval"},
                    {source: "skill_doc", target: "execute", label: "Instructions", type: "data"}
                ],
                description: "Only load skill details when needed (saves ~65k tokens!)"
            },
            heartbeat: {
                title: "Heartbeat Self-Monitoring",
                nodes: [
                    {id: "timer", label: "Timer (30min)", sublabel: "Configurable interval", x: 150, y: 100, color: "#f39c12"},
                    {id: "trigger", label: "Heartbeat Trigger", sublabel: "Run in main session", x: 400, y: 100, color: "#f39c12"},
                    {id: "checks", label: "Batched Checks", sublabel: "Email, calendar, tasks, etc.", x: 650, y: 100, color: "#9b59b6"},
                    {id: "memory", label: "Check Memory", sublabel: "Today + Yesterday logs", x: 650, y: 50, color: "#e74c3c"},
                    {id: "decision", label: "Prioritize", sublabel: "What needs attention?", x: 900, y: 100, color: "#9b59b6"},
                    {id: "action", label: "Action (if needed)", sublabel: "Send notification, update", x: 1150, y: 100, color: "#16a085"},
                    {id: "wait", label: "Wait", sublabel: "Sleep until next beat", x: 1150, y: 180, color: "#34495e"}
                ],
                links: [
                    {source: "timer", target: "trigger", label: "Fire", type: "control"},
                    {source: "trigger", target: "checks", label: "Run", type: "data"},
                    {source: "trigger", target: "memory", label: "Read", type: "retrieval"},
                    {source: "checks", target: "decision", label: "Results", type: "data"},
                    {source: "memory", target: "decision", label: "Context", type: "data"},
                    {source: "decision", target: "action", label: "If urgent", type: "control"},
                    {source: "decision", target: "wait", label: "If nothing", type: "control"}
                ],
                description: "Cost-optimized self-monitoring every 30 minutes"
            },
            full: {
                title: "Complete OpenClaw Architecture",
                nodes: [
                    {id: "channels", label: "Multi-Channel Input", sublabel: "Discord, WhatsApp, Telegram", x: 100, y: 200, color: "#3498db"},
                    {id: "gateway", label: "Gateway", sublabel: "WebSocket server", x: 250, y: 200, color: "#9b59b6"},
                    {id: "router", label: "Session Router", sublabel: "per-sender isolation", x: 400, y: 200, color: "#9b59b6"},
                    {id: "session", label: "Session Context", sublabel: "~130k tokens", x: 550, y: 200, color: "#e74c3c"},
                    {id: "daily", label: "Daily Logs", sublabel: "memory/*.md", x: 550, y: 320, color: "#e74c3c"},
                    {id: "semantic", label: "MEMORY.md", sublabel: "Curated knowledge", x: 700, y: 320, color: "#e74c3c"},
                    {id: "skills", label: "Skills (700+)", sublabel: "Progressive disclosure", x: 850, y: 320, color: "#2ecc71"},
                    {id: "llm", label: "LLM", sublabel: "Claude/GPT", x: 700, y: 200, color: "#9b59b6"},
                    {id: "tools", label: "Tools", sublabel: "bash, browser, etc.", x: 850, y: 200, color: "#16a085"},
                    {id: "output", label: "Output", sublabel: "Responses, actions", x: 1000, y: 200, color: "#3498db"},
                    {id: "heartbeat", label: "Heartbeat", sublabel: "30min self-check", x: 700, y: 80, color: "#f39c12"},
                    {id: "error", label: "Error Handler", sublabel: "try/catch/retry", x: 850, y: 80, color: "#e67e22"}
                ],
                links: [
                    {source: "channels", target: "gateway", label: "", type: "data"},
                    {source: "gateway", target: "router", label: "", type: "data"},
                    {source: "router", target: "session", label: "", type: "data"},
                    {source: "session", target: "daily", label: "Consolidate", type: "memory"},
                    {source: "session", target: "llm", label: "", type: "data"},
                    {source: "daily", target: "semantic", label: "Curate", type: "memory"},
                    {source: "semantic", target: "llm", label: "Retrieve", type: "retrieval"},
                    {source: "skills", target: "llm", label: "Load", type: "retrieval"},
                    {source: "llm", target: "tools", label: "Call", type: "data"},
                    {source: "llm", target: "output", label: "", type: "data"},
                    {source: "heartbeat", target: "llm", label: "Monitor", type: "control"},
                    {source: "tools", target: "error", label: "On fail", type: "control"}
                ],
                description: "High-level overview of major components"
            }
        };

        let currentScenario = 'message_flow';
        let svg, g, simulation, selectedNode = null;

        function loadScenario(scenarioName) {
            currentScenario = scenarioName;

            // Update button states
            document.querySelectorAll('.scenario-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            renderGraph();
        }

        function renderGraph() {
            const scenario = scenarios[currentScenario];

            // Clear existing
            d3.select('#graph').selectAll('*').remove();

            svg = d3.select('#graph');
            const width = 1560;
            const height = 800;

            // Add arrow marker
            svg.append('defs').append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '0 0 10 10')
                .attr('refX', 20)
                .attr('refY', 5)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 0 L 10 5 L 0 10 z')
                .attr('fill', '#4a90e2');

            g = svg.append('g');

            // Create links
            const links = g.selectAll('.link')
                .data(scenario.links)
                .join('line')
                .attr('class', d => `link ${d.type}`)
                .attr('x1', d => {
                    const source = scenario.nodes.find(n => n.id === d.source);
                    return source.x;
                })
                .attr('y1', d => {
                    const source = scenario.nodes.find(n => n.id === d.source);
                    return source.y;
                })
                .attr('x2', d => {
                    const target = scenario.nodes.find(n => n.id === d.target);
                    return target.x;
                })
                .attr('y2', d => {
                    const target = scenario.nodes.find(n => n.id === d.target);
                    return target.y;
                });

            // Create link labels
            const linkLabels = g.selectAll('.link-label')
                .data(scenario.links)
                .join('text')
                .attr('class', 'link-label')
                .attr('x', d => {
                    const source = scenario.nodes.find(n => n.id === d.source);
                    const target = scenario.nodes.find(n => n.id === d.target);
                    return (source.x + target.x) / 2;
                })
                .attr('y', d => {
                    const source = scenario.nodes.find(n => n.id === d.source);
                    const target = scenario.nodes.find(n => n.id === d.target);
                    return (source.y + target.y) / 2 - 5;
                })
                .text(d => d.label);

            // Create nodes
            const nodes = g.selectAll('.node')
                .data(scenario.nodes)
                .join('circle')
                .attr('class', 'node')
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('r', 35)
                .attr('fill', d => d.color)
                .on('click', (event, d) => showInfo(d));

            // Create node labels
            const labels = g.selectAll('.node-label')
                .data(scenario.nodes)
                .join('text')
                .attr('class', 'node-label')
                .attr('x', d => d.x)
                .attr('y', d => d.y - 50)
                .text(d => d.label);

            const sublabels = g.selectAll('.node-sublabel')
                .data(scenario.nodes)
                .join('text')
                .attr('class', 'node-sublabel')
                .attr('x', d => d.x)
                .attr('y', d => d.y - 35)
                .text(d => d.sublabel);
        }

        function showInfo(node) {
            const panel = document.getElementById('info-panel');
            panel.style.display = 'block';
            document.getElementById('info-title').textContent = node.label;
            document.getElementById('info-implementation').textContent = node.sublabel;

            const details = getNodeDetails(node.id);
            document.getElementById('info-details').textContent = details;
        }

        function getNodeDetails(nodeId) {
            const info = {
                discord: "Discord.js bot with Message Content Intent. Normalizes messages before routing.",
                gateway: "WebSocket server running on port 18789. Single control plane for all channels.",
                router: "Deterministic routing based on channel+sender. Ensures session isolation.",
                attention: "Checks requireMention, groupPolicy, DM pairing before processing.",
                session: "Current conversation context. Uses prompt caching (1hr TTL).",
                llm: "Model-agnostic inference. Supports Claude, GPT, Gemini.",
                tools: "Built-in tools + skills system. Streaming responses.",
                response: "Channel-specific formatting. Supports reactions, threads, pins.",
                trigger: "Fires when session context exceeds capacity OR on explicit save.",
                daily: "Append-only markdown logs. No automatic cleanup (grows forever).",
                vector: "Semantic search using local/OpenAI/Gemini embeddings. ~400 token chunks.",
                semantic: "Manually curated by user. Main session only (private).",
                search: "memory_search tool returns ~700 char snippets with scores.",
                system: "Assembled fresh every turn. Includes tools, skills index, bootstrap files.",
                index: "Just name+description+location for 700 skills. ~5-10k tokens total.",
                read: "On-demand skill loading when LLM matches task to skill description.",
                skill_doc: "Full SKILL.md markdown with instructions. Only loaded when needed.",
                execute: "Skill-specific tools and scripts run in sandboxed environment.",
                timer: "Configurable interval (default 30min). Cost optimization strategy.",
                checks: "Batched monitoring: email, calendar, tasks, notifications, etc.",
                memory: "Reads today + yesterday logs for context.",
                decision: "Context-aware prioritization of what needs user attention.",
                action: "Only acts if something urgent. Otherwise silent.",
                wait: "Sleeps until next heartbeat. Saves token costs.",
                channels: "Multi-channel support: Discord, WhatsApp, Telegram, Slack, Signal.",
                skills: "700+ skills from ClawdHub. Progressive disclosure pattern.",
                output: "Streaming responses with channel-specific formatting.",
                heartbeat: "Batched self-monitoring every 30 minutes (configurable).",
                error: "try/catch/finally with exponential backoff retry."
            };
            return info[nodeId] || "No additional details.";
        }

        // Initial render
        renderGraph();
    </script>
</body>
</html>
